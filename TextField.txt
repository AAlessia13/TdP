1) Inserimento parametro riferito ai nodi tramite TextField
Nel caso in cui il parametro inserito faccia riferimento a gli archi o al peso di essi
la parte di view e di controller rimane invariata. Il parametro viene invece considerato
nella parte del model e NON NELLA QUERY.

        Passaggi chiave per la costruzione di un grafo
        1️⃣ Costruisci i nodi
        nodes = DAO.getSomething()
        graph.add_nodes_from(nodes)

        2️⃣ Costruisci la mappa
        idMap = {obj.id: obj for obj in graph.nodes}

        3️⃣ Passi idMap al DAO degli archi
        edges = DAO.getEdges(idMap)
        graph.add_edges_from(edges)

        QUANDO idMap NON SERVE
        1️⃣ I nodi sono già ID
        2️⃣ Gli archi non arrivano dal DB

        # DAO
        # VERTICI: tutti gli album musicali (tabella Album) la cui durata (intesa come somma delle durate
        # dei brani ad esso appartenenti) sia superiore a d.
        @staticmethod
        def getAlbums(d):
            cnx = DBConnect.get_connection()
            result = []
            if cnx is None:
                print("Connessione fallita")
            else:
                cursor = cnx.cursor(dictionary=True)
                query = """ SELECT a.AlbumId , a.Title, a.ArtistId, SUM(t.Milliseconds) as totD
                            FROM album a , track t
                            WHERE a.AlbumId = t.AlbumId
                            GROUP BY a.AlbumId
                            HAVING totD > %s"""
                cursor.execute(query, (d,))
                for row in cursor:
                    result.append(Album(**row)) #DTO
                cursor.close()
                cnx.close()
                return result


        @staticmethod
        def getEdges(idMap):
            cnx = DBConnect.get_connection()
            result = []
            if cnx is None:
                print("Connessione fallita")
            else:
                cursor = cnx.cursor(dictionary=True)
                query = """ SELECT DISTINCTROW t.AlbumId as a1, t2.AlbumId as a2
                            FROM playlisttrack p, track t , playlisttrack p2 , track t2
                            WHERE p2.PlaylistId = p.PlaylistId
                            AND p2.TrackId = t2.TrackId AND p.TrackId = t.TrackId
                            AND t.AlbumId < t2.AlbumId
                            """
                cursor.execute(query)
                for row in cursor:
                    if row["a1"] in idMap and row["a2"] in idMap:
                        result.append( (idMap[row["a1"]], idMap[row["a2"]] ))
                cursor.close()
                cnx.close()
                return result


        # Model
        class Model:
            def __init__(self):
            self.graph = nx.Graph()
            self._idMap = {}

            def buildGraph(self, d): # qua metto tutti i parametri sia dei nodi che degli archi
                # pulire grafo
                self.graph.clear()

                # nodi
                    """
                    self._nodi = DAO.getAlbums(toMillisec(d))
                    self._grafo.add_nodes_from(self._nodi)
                    """
                self.graph.add_nodes_from(DAO.getAlbums(toMillisec(d)))

                self._idMap = {a.AlbumId : a for a in self.graph.nodes}
                    """
                    class Model:
                        def __init__(self):
                            self._airports = DAO.getAllAirports()
                            self._idMap = {}
                            for a in self._airports:
                                self._idMap[a.ID] = a
                    """

                # archi
                edges = DAO.getEdges(self._idMap)
                self.graph.add_edges_from(edges)

                # si tratta di non grafo non pesato quindi non ci sono pesi

        def toMillisec(d):
           return d*60*1000

        # Controller
        def handleCreaGrafo(self, e):
        --- CONTROLLO DI UN NUMERO INSERITO NEL TXTIN ---
        totDint = self._view._txtAnno.value
        if totDint == "" (or distanza_min is None):
            self._view.txt_result.controls.clear() # pulire ListView
            self._view.txt_result.append(ft.Text(f"Distanza non inserito"))
            self._view.update_page()
            return

        try:
            d = int(totDint)
            """
            # Se bisogna far rispettare degli intervalli
            if intAnno < 1816 or intAnno > 2006:
                self._view._txt_result.controls.append(ft.Text(f'Devi inserire un anno compreso tra il 1816 e il 2006.'))
            """
        except ValueError:
            self._view._txt_result.controls.clear() # pulire ListView
            self._view._txt_result.controls.append(ft.Text("Il valore inserito nel campo d non è un intero!"))
            self._view.update_page()
            return

        # Se tutto va bene costruzione del grafo
        self._model.buildGraph(d) # chiamiamo la funzione di costruzione di un grafo e gli passiamo il parametro
        self._view.txt_result.controls.append(ft.Text("Grafo correttamente creato!"))

        # Stampiamo numero di nodi e archi
        nN, nE = self._model.getGraphSize()
        self._view.txt_result.controls.append(ft.Text(f"Il grafo ha {nN} nodi e {nE} archi!"))

                # Model
                def getGraphSize(self):
                    return len(self.graph.nodes), len(self.graph.edges)

        # Se nell'ultima richiesta viene chiesto
        # "Permettere all'utente di selezionare, dall'apposita tendina, un album a1 (un nodo)
        # tra quelli presenti nel grafo" :  che vorrebbe dire fare un dropdown di oggetti essendo che
        # per i nodi è stata creata una DTO
        --- NEL CASO FOSSERO DUE TENDINE DA RIMPIERE NELLO STESSO MODO LA PROCEDURA è LA STESSA
        MA SI RADDOPPIA TUTTO (GUARDA Classroom > FlightDelays)
        ????
        nodes = self._model.getNodes()
        nodes.sort(key=lambda x: x.Title)
        """
        for n in nodes:
            self._view._ddAlbum.options.append(
                ft.dropdown.Option(
                    data=n,
                    text=n.Title, #id
                    on_click=self.getSelectedAlbum
                )
            )
        """
        listDD = map(lambda x: ft.dropdown.Option(data=x, text=x.Title, on_click=self.getSelectedAlbum), nodes)
        self._view._ddAlbum.options = listDD

        self._view.update_page()

        def getSelectedAlbum(self, e):
            if e.control.data is None:
                self._choiceAlbum = None  # self._choiceAlbum = None in def __init__
            else:
                self._choiceAlbum = e.control.data


        # View
        # Permette l'inserimento di un dato, il bottone per creare un grafo,
        # il riempimento della tendina con i nodi del grafo e lo spazio per stampare il tutto

        self._txtInDurata = ft.TextField(label="Durata")
        self._btnCreaGrafo = ft.ElevatedButton(text="Crea Grafo",
                                               on_click=self._controller.handleCreaGrafo) #

        self._ddAlbum = ft.Dropdown(label="Album")

        self.txt_result = ft.ListView(expand=1, spacing=10, padding=20, auto_scroll=True)